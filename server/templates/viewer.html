<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IFC Component Viewer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #1e1e1e;
            color: #e0e0e0;
            height: 100vh;
            overflow: hidden;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* Query Input Section */
        .query-section {
            background: #2d2d2d;
            border-bottom: 1px solid #444;
            padding: 12px 16px;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-shrink: 0;
        }

        .query-input-wrapper {
            flex: 1;
            display: flex;
            gap: 8px;
        }

        #queryInput {
            flex: 1;
            padding: 8px 12px;
            background: #3d3d3d;
            border: 1px solid #555;
            border-radius: 4px;
            color: #e0e0e0;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 12px;
        }

        #queryInput::placeholder {
            color: #888;
        }

        #queryInput:focus {
            outline: none;
            border-color: #0098ff;
            box-shadow: 0 0 8px rgba(0, 152, 255, 0.3);
        }

        button {
            padding: 8px 16px;
            background: #0098ff;
            border: none;
            border-radius: 4px;
            color: white;
            cursor: pointer;
            font-weight: 600;
            font-size: 12px;
            transition: background 0.2s;
        }

        button:hover {
            background: #0078cc;
        }

        button:active {
            background: #005fa3;
        }

        /* Status indicator */
        .status-info {
            display: flex;
            gap: 12px;
            align-items: center;
            font-size: 12px;
            color: #aaa;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #4ade80;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Main Content Section */
        .content-section {
            display: flex;
            flex: 1;
            min-height: 0;
            gap: 8px;
            padding: 8px;
        }

        /* Left Panel - Tree View */
        .left-panel {
            width: min(33%, 400px);
            background: #2d2d2d;
            border: 1px solid #444;
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .tree-header {
            padding: 12px;
            border-bottom: 1px solid #444;
            font-weight: 600;
            font-size: 13px;
            background: #252525;
        }

        /* Tab Navigation */
        .tab-bar {
            display: flex;
            background: #252525;
            border-bottom: 1px solid #444;
            gap: 0;
        }

        .tab-button {
            flex: 1;
            padding: 10px 12px;
            background: #2d2d2d;
            border: none;
            border-bottom: 2px solid #444;
            color: #999;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            border-radius: 0;
        }

        .tab-button:hover {
            background: #383838;
            color: #bbb;
        }

        .tab-button.active {
            background: #252525;
            color: #0098ff;
            border-bottom: 2px solid #0098ff;
        }

        .tab-content {
            display: none;
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
        }

        .tab-content.active {
            display: flex;
            flex-direction: column;
        }

        .tree-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
        }

        .tree-item {
            border-left: 2px solid transparent;
            transition: background 0.15s;
        }

        .tree-item:hover {
            background: #3d3d3d;
        }

        .tree-item-content {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            cursor: pointer;
            user-select: none;
            font-size: 12px;
        }

        .tree-item.selected > .tree-item-content {
            background: #0098ff;
            color: white;
            border-left-color: #0078cc;
        }

        .tree-toggle {
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            cursor: pointer;
        }

        .tree-toggle::before {
            content: '‚ñ∂';
            font-size: 10px;
            transition: transform 0.15s;
            display: inline-block;
        }

        .tree-item.expanded > .tree-item-content .tree-toggle::before {
            transform: rotate(90deg);
        }

        .tree-checkbox {
            width: 16px;
            height: 16px;
            flex-shrink: 0;
            cursor: pointer;
            accent-color: #ffffff;
            background-color: transparent;
            appearance: none;
            border: 1px solid #555;
            border-radius: 2px;
        }
        
        .tree-checkbox:checked {
            background-color: #888888;
            border-color: #555;
        }

        .tree-icon {
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            flex-shrink: 0;
            margin-right: 4px;
        }

        .tree-icon.entity { color: #b0b0b0; }     /* Light grey for entities */
        .tree-icon.relation { color: #f8d700; }   /* Yellow for relations */
        .tree-icon.mesh { color: #85e89d; }       /* Green for mesh/representation */
        .tree-icon.property { color: #f8b500; }   /* Orange for properties */
        .tree-icon.component { color: #56b6f2; }  /* Cyan for components */
        .tree-icon.component-with-entity { color: #4da6ff; }  /* Blue for components with entityType */

        .tree-label {
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .tree-label.entity-name { color: #b0b0b0; }      /* Light grey */
        .tree-label.relation-name { color: #f8d700; }    /* Yellow */
        .tree-label.mesh-name { color: #85e89d; }        /* Green */
        .tree-label.property-name { color: #f8b500; }    /* Orange */
        .tree-label.component-name { color: #56b6f2; }   /* Cyan */
        .tree-label.component-with-entity-name { color: #4da6ff; }   /* Blue for components with entityType */

        .tree-label-guid {
            font-size: 10px;
            color: #888;
            margin-left: 6px;
            font-family: 'Monaco', 'Menlo', monospace;
        }

        .tree-item[title] {
            cursor: help;
        }

        .tree-count {
            font-size: 11px;
            color: #888;
            margin-left: auto;
        }

        .tree-children {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.2s ease-out;
        }

        .tree-item.expanded > .tree-children {
            max-height: 2000px;
        }

        .tree-children > .tree-item {
            margin-left: 16px;
        }

        /* Right Panel - 3D Viewer */
        .right-panel {
            flex: 1;
            background: #2d2d2d;
            border: 1px solid #444;
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .viewer-header {
            padding: 12px;
            border-bottom: 1px solid #444;
            font-weight: 600;
            font-size: 13px;
            background: #252525;
        }

        #canvas3d {
            flex: 1;
            background: #1a1a1a;
        }

        .viewer-controls {
            padding: 8px 12px;
            display: flex;
            gap: 8px;
            border-top: 1px solid #444;
            background: #252525;
            font-size: 11px;
        }

        .viewer-control-group {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .viewer-control-group label {
            color: #aaa;
        }

        .viewer-control-group input[type="checkbox"] {
            accent-color: #ffffff;
            cursor: pointer;
            background-color: transparent;
            appearance: none;
            width: 16px;
            height: 16px;
            border: 1px solid #555;
            border-radius: 2px;
        }
        
        .viewer-control-group input[type="checkbox"]:checked {
            background-color: #888888;
            border-color: #555;
        }

        .control-separator {
            width: 1px;
            height: 16px;
            background: #444;
        }

        /* Bottom Panel - Data Table */
        .bottom-panel {
            display: none;
        }

        .table-header {
            padding: 12px;
            border-bottom: 1px solid #444;
            font-weight: 600;
            font-size: 13px;
            background: #252525;
            display: flex;
            justify-content: space-between;
        }

        .table-content {
            flex: 1;
            overflow: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
        }

        thead {
            background: #252525;
            border-bottom: 1px solid #444;
            position: sticky;
            top: 0;
        }

        th {
            padding: 8px 12px;
            text-align: left;
            font-weight: 600;
            color: #aaa;
            white-space: nowrap;
            background: #252525;
        }

        td {
            padding: 8px 12px;
            border-bottom: 1px solid #3d3d3d;
            max-width: 300px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        tr:hover {
            background: #383838;
        }

        tbody tr:nth-child(even) {
            background: #2a2a2a;
        }

        /* Scrollbars */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #2d2d2d;
        }

        ::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #666;
        }

        /* Loading indicator */
        .loading {
            display: inline-block;
            width: 8px;
            height: 8px;
            background: #0098ff;
            border-radius: 50%;
            animation: blink 1s infinite;
            margin-left: 4px;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        /* Empty state */
        .empty-state {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #666;
            font-size: 13px;
            text-align: center;
        }

        .empty-state code {
            background: #3d3d3d;
            padding: 2px 6px;
            border-radius: 2px;
            color: #0098ff;
            font-family: 'Monaco', monospace;
            font-size: 11px;
            white-space: nowrap;
        }

        /* Tooltips */
        [data-tooltip] {
            position: relative;
        }

        [data-tooltip]:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            background: #000;
            color: #fff;
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 10px;
            white-space: nowrap;
            bottom: 120%;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            pointer-events: none;
            border: 1px solid #444;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Query Input Section -->
        <div class="query-section">
            <div class="query-input-wrapper">
                <input 
                    type="text" 
                    id="queryInput" 
                    placeholder="Enter REST query (e.g., http://localhost:5000/api/entityGuids?entityTypes=IfcWall or /api/componentGuids?models=HelloWall)"
                >
                <button id="executeBtn">Execute</button>
                <button id="clearBtn" title="Clear results">Clear</button>
            </div>
            <div class="status-info">
                <div class="status-dot"></div>
                <span id="statusText">Ready</span>
            </div>
        </div>

        <!-- Main Content: Tree + 3D Viewer + Data Table -->
        <div class="content-section">
            <!-- Left: Entity/Component Tree with Tabs -->
            <div class="left-panel">
                <!-- Tab Navigation -->
                <div class="tab-bar">
                    <button class="tab-button active" data-tab="entities">E/C</button>
                    <button class="tab-button" data-tab="information">‚ÑπÔ∏è Info</button>
                    <button class="tab-button" data-tab="settings">‚öôÔ∏è</button>
                </div>

                <!-- Tab Content: Entities & Components -->
                <div class="tab-content active" id="entitiesTab">
                    <div class="tree-content" id="treeContainer">
                        <div class="empty-state">Execute a query to load data</div>
                    </div>
                </div>

                <!-- Tab Content: Information -->
                <div class="tab-content" id="informationTab">
                    <div style="padding: 12px; flex: 1; overflow-y: auto; display: flex; flex-direction: column; align-items: flex-start;">
                        <div id="infoContainer" style="color: #666; font-size: 13px;">Execute a query to see information</div>
                    </div>
                </div>

                <!-- Tab Content: Settings -->
                <div class="tab-content" id="settingsTab">
                    <div style="padding: 12px; flex: 1; overflow-y: auto;">
                        <div style="color: #999; font-size: 12px;">Settings coming soon</div>
                    </div>
                </div>
            </div>

            <!-- Right: 3D Viewer -->
            <div style="flex: 1; display: flex; flex-direction: column;">
                <div class="right-panel" style="flex: 1;">
                    <div class="viewer-header">3D View</div>
                    <canvas id="canvas3d"></canvas>
                    <div class="viewer-controls">
                        <div class="viewer-control-group">
                            <input type="checkbox" id="showGrid" checked>
                            <label for="showGrid">Grid</label>
                        </div>
                        <div class="control-separator"></div>
                        <div class="viewer-control-group">
                            <input type="checkbox" id="showAxes" checked>
                            <label for="showAxes">Axes</label>
                        </div>
                        <div class="control-separator"></div>
                        <button id="resetView" style="padding: 4px 12px; font-size: 11px;">Reset View</button>
                        <button id="fitAll" style="padding: 4px 12px; font-size: 11px;">Fit All</button>
                    </div>
                </div>

                <!-- Bottom: Data Table -->
                <div class="bottom-panel">
                    <div class="table-header">
                        <span>Component Data <span id="rowCount"></span></span>
                        <span id="tableStatus"></span>
                    </div>
                    <div class="table-content" id="tableContainer">
                        <div class="empty-state">No data selected</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // 3D VIEWER SETUP (Three.js)
        // ============================================
        let scene, camera, renderer, controls;
        const objects3d = new Map(); // componentGuid -> mesh
        const selectedGuids = new Set();
        let gridHelper, axesHelper;
        let panTarget; // Track the pan/orbit center point

        function init3DViewer() {
            const canvas = document.getElementById('canvas3d');
            const container = canvas.parentElement;

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);

            // Camera
            const width = container.clientWidth;
            const height = container.clientHeight;
            camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 10000);
            camera.up.set(0, 0, 1); // Z axis points up (right-hand rule)
            camera.position.set(10, -10, 10); // View from back-left-top
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(width, height);
            renderer.setPixelRatio(window.devicePixelRatio);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(100, 100, 100);
            scene.add(directionalLight);

            // Grid
            gridHelper = new THREE.GridHelper(500, 50, 0x444444, 0x222222);
            gridHelper.rotation.x = Math.PI / 2; // Rotate to XY plane (Z pointing up)
            scene.add(gridHelper);

            // Axes
            axesHelper = new THREE.AxesHelper(50);
            scene.add(axesHelper);

            // Simple orbit-like controls via mouse
            panTarget = new THREE.Vector3(0, 0, 0); // Initialize pan target at origin
            setupMouseControls();

            // Handle window resize
            window.addEventListener('resize', () => {
                const newWidth = container.clientWidth;
                const newHeight = container.clientHeight;
                camera.aspect = newWidth / newHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(newWidth, newHeight);
            });

            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                renderer.render(scene, camera);
            }
            animate();

            // Control event listeners
            document.getElementById('showGrid').addEventListener('change', (e) => {
                gridHelper.visible = e.target.checked;
            });

            document.getElementById('showAxes').addEventListener('change', (e) => {
                axesHelper.visible = e.target.checked;
            });

            document.getElementById('resetView').addEventListener('click', () => {
                camera.up.set(0, 0, 1); // Z axis points up
                camera.position.set(-100, -100, 100); // View from back-left-top
                panTarget.set(0, 0, 0); // Reset pan target to origin
                camera.lookAt(0, 0, 0);
            });

            document.getElementById('fitAll').addEventListener('click', fitAllObjects);
        }

        function setupMouseControls() {
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };

            const canvas = document.getElementById('canvas3d');

            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            canvas.addEventListener('mousemove', (e) => {
                if (!isDragging) return;

                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;

                if (e.shiftKey) {
                    // Pan mode: move camera and target together
                    const radius = camera.position.length();
                    
                    // Calculate camera's right and up vectors for panning in screen space
                    const forward = new THREE.Vector3()
                        .subVectors(panTarget, camera.position)
                        .normalize();
                    const right = new THREE.Vector3()
                        .crossVectors(forward, camera.up)
                        .normalize();
                    const up = new THREE.Vector3()
                        .crossVectors(right, forward)
                        .normalize();
                    
                    // Pan amount proportional to camera distance
                    const panSpeed = radius * 0.005;
                    const panX = right.multiplyScalar(-deltaX * panSpeed);
                    const panY = up.multiplyScalar(deltaY * panSpeed);
                    
                    // Move both camera and target
                    panTarget.add(panX).add(panY);
                    camera.position.add(panX).add(panY);
                    camera.lookAt(panTarget);
                } else {
                    // Rotate mode: orbit around target
                    const offsetPos = new THREE.Vector3()
                        .subVectors(camera.position, panTarget);
                    const radius = offsetPos.length();
                    
                    const theta = Math.atan2(offsetPos.y, offsetPos.x) - deltaX * 0.01;
                    const phi = Math.acos(offsetPos.z / radius) - deltaY * 0.01;

                    const clampedPhi = Math.max(0.1, Math.min(Math.PI - 0.1, phi));
                    offsetPos.x = radius * Math.sin(clampedPhi) * Math.cos(theta);
                    offsetPos.y = radius * Math.sin(clampedPhi) * Math.sin(theta);
                    offsetPos.z = radius * Math.cos(clampedPhi);
                    
                    camera.position.copy(panTarget).add(offsetPos);
                    camera.up.set(0, 0, 1); // Preserve Z-up orientation
                    camera.lookAt(panTarget);
                }

                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            canvas.addEventListener('mouseup', () => {
                isDragging = false;
            });

            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const offsetPos = new THREE.Vector3().subVectors(camera.position, panTarget);
                const radius = offsetPos.length();
                const newRadius = Math.max(10, Math.min(1000, radius + e.deltaY * 0.1));
                const scale = newRadius / radius;
                offsetPos.multiplyScalar(scale);
                camera.position.copy(panTarget).add(offsetPos);
                camera.up.set(0, 0, 1); // Preserve Z-up orientation when zooming
            });
        }

        function fitAllObjects() {
            if (objects3d.size === 0) {
                console.log("fitAllObjects: No objects to fit");
                return;
            }

            console.log(`üìè fitAllObjects: Calculating bounds for ${objects3d.size} objects`);
            
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            let minZ = Infinity, maxZ = -Infinity;
            let validMeshes = 0;

            objects3d.forEach((mesh, guid) => {
                if (!mesh.visible) {
                    console.log(`  Skipping invisible mesh: ${guid}`);
                    return;
                }

                const box = new THREE.Box3().setFromObject(mesh);
                
                if (box.min.x === Infinity || box.max.x === -Infinity) {
                    console.warn(`  Mesh ${guid} has invalid bounds`);
                    return;
                }

                minX = Math.min(minX, box.min.x);
                maxX = Math.max(maxX, box.max.x);
                minY = Math.min(minY, box.min.y);
                maxY = Math.max(maxY, box.max.y);
                minZ = Math.min(minZ, box.min.z);
                maxZ = Math.max(maxZ, box.max.z);
                validMeshes++;
                console.log(`  Mesh ${guid.substring(0, 20)}... bounds: (${box.min.x.toFixed(2)}, ${box.min.y.toFixed(2)}, ${box.min.z.toFixed(2)}) to (${box.max.x.toFixed(2)}, ${box.max.y.toFixed(2)}, ${box.max.z.toFixed(2)})`);
            });

            if (validMeshes === 0) {
                console.warn("fitAllObjects: No visible meshes with valid bounds");
                return;
            }

            console.log(`‚úì Valid bounds from ${validMeshes} meshes`);
            console.log(`  Overall bounds: (${minX.toFixed(2)}, ${minY.toFixed(2)}, ${minZ.toFixed(2)}) to (${maxX.toFixed(2)}, ${maxY.toFixed(2)}, ${maxZ.toFixed(2)})`);

            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            const centerZ = (minZ + maxZ) / 2;

            const sizeX = maxX - minX;
            const sizeY = maxY - minY;
            const sizeZ = maxZ - minZ;
            const maxSize = Math.max(sizeX, sizeY, sizeZ);
            
            console.log(`  Center: (${centerX.toFixed(2)}, ${centerY.toFixed(2)}, ${centerZ.toFixed(2)})`);
            console.log(`  Size: ${sizeX.toFixed(2)} x ${sizeY.toFixed(2)} x ${sizeZ.toFixed(2)}, max: ${maxSize.toFixed(2)}`);

            // Calculate distance with buffer to ensure full view
            const vFOV = camera.fov * Math.PI / 180; // convert vertical FOV to radians
            const distance = (maxSize / 2) / Math.tan(vFOV / 2) + (maxSize * 0.2); // add 20% buffer

            console.log(`  Positioning camera at distance ${distance.toFixed(2)} from center`);
            
            // Set the pan target to the center of the bounding box
            panTarget.set(centerX, centerY, centerZ);
            
            camera.up.set(0, 0, 1); // Ensure Z points up
            camera.position.set(
                centerX - distance * 0.866, // position from back-left-top
                centerY - distance * 0.866,
                centerZ + distance * 0.866
            );
            camera.lookAt(centerX, centerY, centerZ);
            
            console.log(`  Camera position: (${camera.position.x.toFixed(2)}, ${camera.position.y.toFixed(2)}, ${camera.position.z.toFixed(2)})`);
        }

        function addMeshToScene(guid, triangles, color = 0x0098ff) {
            // Convert triangle data to Three.js geometry
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const indices = [];

            triangles.forEach((tri, idx) => {
                if (Array.isArray(tri) && tri.length >= 3) {
                    const p1 = tri[0], p2 = tri[1], p3 = tri[2];
                    vertices.push(p1[0], p1[1], p1[2]);
                    vertices.push(p2[0], p2[1], p2[2]);
                    vertices.push(p3[0], p3[1], p3[2]);
                    const baseIdx = idx * 3;
                    indices.push(baseIdx, baseIdx + 1, baseIdx + 2);
                }
            });

            geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices), 3));
            geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(indices), 1));
            geometry.computeVertexNormals();

            const material = new THREE.MeshPhongMaterial({
                color: color,
                emissive: 0x000000,
                shininess: 100,
                wireframe: false,
                side: THREE.DoubleSide
            });

            const mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);
            objects3d.set(guid, mesh);
        }

        function updateMeshVisibility(guid, visible) {
            const mesh = objects3d.get(guid);
            if (mesh) {
                mesh.visible = visible;
            }
        }

        // Simple OBJ parser for handling OBJ strings
        function parseOBJString(objString) {
            const lines = objString.split('\n');
            const vertices = [];
            const faces = [];

            lines.forEach(line => {
                const parts = line.trim().split(/\s+/);
                if (parts.length === 0) return;

                if (parts[0] === 'v' && parts.length >= 4) {
                    // Vertex definition: v x y z
                    vertices.push(
                        parseFloat(parts[1]),
                        parseFloat(parts[2]),
                        parseFloat(parts[3])
                    );
                } else if (parts[0] === 'f' && parts.length >= 4) {
                    // Face definition: f idx1 idx2 idx3 (1-based indices)
                    for (let i = 1; i < parts.length - 2; i++) {
                        // Parse face indices (could be "1", "1/1", or "1/1/1" format)
                        const i1 = parseInt(parts[1].split('/')[0]) - 1;
                        const i2 = parseInt(parts[i + 1].split('/')[0]) - 1;
                        const i3 = parseInt(parts[i + 2].split('/')[0]) - 1;
                        faces.push(i1, i2, i3);
                    }
                }
            });

            if (vertices.length === 0 || faces.length === 0) {
                console.warn('parseOBJString: No vertices or faces found');
                return null;
            }

            // Create Three.js geometry
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices), 3));
            geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(faces), 1));
            geometry.computeVertexNormals();

            return geometry;
        }

        function renderComponentShapes(componentGuid, componentData) {
            if (!componentData) {
                console.warn(`renderComponentShapes: No component data for ${componentGuid}`);
                return;
            }

            console.log(`üîç renderComponentShapes called for ${componentGuid}`);
            console.log(`   Full component data:`, componentData);
            console.log(`   Component data keys:`, Object.keys(componentData));

            // CHECK IF SHAPES ALREADY RENDERED: If any mesh for this component exists in objects3d, skip rendering
            let alreadyRendered = false;
            objects3d.forEach((mesh, meshId) => {
                if (meshId.startsWith(componentGuid + '-item-')) {
                    alreadyRendered = true;
                }
            });
            if (alreadyRendered) {
                console.log(`‚úì Shapes for ${componentGuid} already rendered, skipping`);
                return;
            }

            // Check if component has Items array (IfcShapeRepresentationComponent)
            const items = componentData.Items || componentData.items;
            if (!Array.isArray(items) || items.length === 0) {
                console.warn(`‚ö†Ô∏è  No items array found in component ${componentGuid}`);
                console.log(`   Checked for: Items, items`);
                console.log(`   Available keys: ${Object.keys(componentData).join(', ')}`);
                return;
            }

            console.log(`‚úì Found ${items.length} items in component ${componentGuid}`);
            
            let meshesCreated = 0;
            // Process each item in the shape representation
            items.forEach((item, idx) => {
                if (!item) {
                    console.warn(`   Item ${idx} is null/undefined`);
                    return;
                }

                console.log(`\n   Processing item ${idx}:`, typeof item);
                
                // Item could be OBJ string data or an object with geometry
                if (typeof item === 'string') {
                    console.log(`   Item ${idx} is OBJ string data (${item.length} chars)`);
                    try {
                        const geometry = parseOBJString(item);
                        if (!geometry) {
                            console.warn(`   ‚úó Failed to parse OBJ string`);
                            return;
                        }
                        
                        const meshId = `${componentGuid}-item-${idx}`;
                        
                        // Material for the OBJ mesh
                        const material = new THREE.MeshPhongMaterial({
                            color: 0x0098ff,
                            emissive: 0x000000,
                            shininess: 100,
                            wireframe: false,
                            side: THREE.DoubleSide
                        });
                        
                        const mesh = new THREE.Mesh(geometry, material);
                        scene.add(mesh);
                        objects3d.set(meshId, mesh);
                        meshesCreated++;
                        console.log(`   ‚úì Added OBJ mesh ${meshId} (vertices: ${geometry.attributes.position.count}, faces: ${geometry.index.count / 3})`);
                    } catch (error) {
                        console.error(`   ‚úó Failed to parse OBJ at item ${idx}:`, error);
                    }
                    return;
                }

                if (typeof item === 'object') {
                    console.log(`   Item ${idx} keys:`, Object.keys(item).slice(0, 15));
                }

                // Try to extract vertices and faces from item
                const vertices = item.vertices || item.Vertices || item.vector || item.Vector || [];
                const faces = item.faces || item.Faces || item.indices || item.Indices || item.triangles || item.Triangles || [];

                console.log(`   Vertices: ${vertices.length} items, Faces: ${faces.length} items`);

                if (vertices.length > 0 && faces.length > 0) {
                    // Create a unique mesh ID for this item
                    const meshId = `${componentGuid}-item-${idx}`;
                    
                    // Create geometry from vertices and faces
                    const geometry = new THREE.BufferGeometry();
                    
                    // Flatten vertices array if needed
                    let flatVertices = [];
                    vertices.forEach(v => {
                        if (Array.isArray(v)) {
                            if (v.length >= 3) {
                                flatVertices.push(v[0], v[1], v[2]);
                            }
                        } else if (v && typeof v === 'object' && v.x !== undefined && v.y !== undefined && v.z !== undefined) {
                            flatVertices.push(v.x, v.y, v.z);
                        }
                    });

                    console.log(`   Flattened vertices: ${flatVertices.length / 3} points`);

                    if (flatVertices.length < 3) {
                        console.warn(`   Not enough vertex data to create mesh`);
                        return;
                    }

                    geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(flatVertices), 3));
                    
                    // Set indices if available
                    if (faces.length > 0) {
                        let flatIndices = [];
                        faces.forEach(f => {
                            if (Array.isArray(f)) {
                                flatIndices.push(...f);
                            } else if (typeof f === 'number') {
                                flatIndices.push(f);
                            }
                        });
                        
                        console.log(`   Flattened indices: ${flatIndices.length}`);
                        
                        if (flatIndices.length > 0) {
                            geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(flatIndices), 1));
                        } else {
                            console.warn(`   Failed to flatten indices`);
                        }
                    }

                    geometry.computeVertexNormals();

                    const material = new THREE.MeshPhongMaterial({
                        color: 0x0098ff,
                        emissive: 0x000000,
                        shininess: 100,
                        wireframe: false,
                        side: THREE.DoubleSide
                    });

                    const mesh = new THREE.Mesh(geometry, material);
                    scene.add(mesh);
                    objects3d.set(meshId, mesh);
                    meshesCreated++;
                    console.log(`   ‚úì Added mesh ${meshId}`);
                } else {
                    console.warn(`   ‚úó Item ${idx} missing geometry (vertices: ${vertices.length}, faces: ${faces.length})`);
                }
            });

            console.log(`\nüìä Summary: Created ${meshesCreated}/${items.length} meshes, total objects3d: ${objects3d.size}`);
        }

        // ============================================
        // DATA MANAGEMENT
        // ============================================
        let currentData = null;

        // Tab switching functionality
        function setupTabSwitching() {
            const tabButtons = document.querySelectorAll('.tab-button');
            const tabContents = document.querySelectorAll('.tab-content');

            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const tabName = button.dataset.tab;
                    
                    // Deactivate all tabs
                    tabButtons.forEach(btn => btn.classList.remove('active'));
                    tabContents.forEach(content => content.classList.remove('active'));
                    
                    // Activate selected tab
                    button.classList.add('active');
                    document.getElementById(tabName + 'Tab').classList.add('active');
                });
            });
        }

        function updateUI(data) {
            console.log('updateUI called with data:', data);
            console.log('  - entities:', Object.keys(data.entities || {}).length);
            console.log('  - components:', Object.keys(data.components || {}).length);
            currentData = data;
            buildTree(data);
            updateTable([]);
            updateInformationView(data);
        }

        function updateInformationView(data) {
            const infoContainer = document.getElementById('infoContainer');
            if (!data) {
                infoContainer.innerHTML = '<div style="color: #666; font-size: 13px;">No data available</div>';
                return;
            }

            // Just display the raw response data as returned by the API
            infoContainer.innerHTML = `<pre style="color: #0098ff; font-size: 11px; font-family: monospace; white-space: pre-wrap; word-wrap: break-word; line-height: 1.4; margin: 0;">${JSON.stringify(data, null, 2)}</pre>`;
        }

        function extractModelName(url) {
            try {
                const urlObj = new URL(url);
                const models = urlObj.searchParams.get('models');
                if (models) return models;
                
                const modelParam = urlObj.searchParams.get('model');
                if (modelParam) return modelParam;
            } catch (e) {
                console.warn('Could not parse model from URL:', e);
            }
            return 'DefaultModel';
        }

        function buildTree(data) {
            const container = document.getElementById('treeContainer');
            container.innerHTML = '';

            if (!data || !data.entities) {
                console.warn('buildTree: No data or entities');
                container.innerHTML = '<div class="empty-state"><div>No data to display</div></div>';
                return;
            }

            // Support for both old single-model and new multi-model formats
            let models = data.models || [];
            let entitiesByModel = data.entities || {};
            
            console.log('buildTree DEBUG INCOMING:');
            console.log('  data.models:', data.models);
            console.log('  entitiesByModel keys:', Object.keys(entitiesByModel));
            console.log('  full entitiesByModel:', JSON.stringify(entitiesByModel, null, 2).substring(0, 2000));
            
            // If no models array, reconstruct from entity keys
            if (!data.models || data.models.length === 0) {
                console.log('  No data.models provided, attempting to derive from data.entities...');
                // When data.entities is {modelName: {entityGuid: [compGuids]}} format
                const firstKey = Object.keys(entitiesByModel)[0];
                if (firstKey) {
                    const firstValue = entitiesByModel[firstKey];
                    console.log('  First key:', firstKey, 'First value type:', typeof firstValue);
                    
                    if (typeof firstValue === 'object' && !Array.isArray(firstValue)) {
                        // Model-organized format
                        models = Object.keys(entitiesByModel);
                        console.log('  ‚úì Detected model-organized: models =', models);
                    } else {
                        // Fallback: wrap in a default model
                        console.log('  ‚ö† Not model-organized, wrapping in default model');
                        const modelName = data.modelName || 'DefaultModel';
                        entitiesByModel = { [modelName]: entitiesByModel };
                        models = [modelName];
                        console.log('  Wrapped as:', { [modelName]: { ...Object.keys(entitiesByModel[modelName]) } });
                    }
                }
            }
            
            console.log('buildTree: After normalization - models:', models, ', entitiesByModel:', Object.keys(entitiesByModel));
            
            // SAFETY CHECK: If models list is empty but we have entities, use entity keys as models
            if (models.length === 0 && Object.keys(entitiesByModel).length > 0) {
                console.log('  SAFETY: models array empty, deriving from entitiesByModel...');
                models = Object.keys(entitiesByModel);
                console.log('  ‚Üí Derived models:', models);
            }
            
            // Calculate total component count across all models
            let totalComponentCount = 0;
            let totalEntityCount = 0;
            let debugInfo = [];
            models.forEach(modelName => {
                const modelEntities = entitiesByModel[modelName] || {};
                const entityCount = Object.keys(modelEntities).length;
                totalEntityCount += entityCount;
                debugInfo.push(`Model "${modelName}": entities=${entityCount}`);
                Object.keys(modelEntities).forEach(entityGuid => {
                    const comps = modelEntities[entityGuid];
                    const isArray = Array.isArray(comps);
                    const count = isArray ? comps.length : 0;
                    totalComponentCount += count;
                });
            });
            
            console.log('Total entity count:', totalEntityCount);
            console.log('Total component count:', totalComponentCount);
            console.log('Debug breakdown:', debugInfo.join('\n'));
            
            // If we have entities but no components, that's OK - just show the entities
            const displayCount = totalComponentCount > 0 ? totalComponentCount : totalEntityCount;
            
            if (totalEntityCount === 0 && totalComponentCount === 0) {
                console.warn('buildTree: No entities or components found');
                container.innerHTML = `<div class="empty-state">
                    <div>
                        <div style="margin-bottom: 12px;"><strong>No data found</strong></div>
                        <div style="margin: 8px 0; font-size: 12px; color: #666;">
                            Try: <code>/api/componentGuids</code> or check 
                            <code>/api/entity_types</code> for available types
                        </div>
                    </div>
                </div>`;
                return;
            }

            // Create root node
            const rootItem = createTreeItem('IFCxPrototype', 'root', displayCount);
            const rootChildren = document.createElement('div');
            rootChildren.className = 'tree-children';

            // LOOP THROUGH EACH MODEL AND CREATE BRANCHES
            models.forEach(modelName => {
                const modelEntities = entitiesByModel[modelName] || {};
                const entityGuids = Object.keys(modelEntities);
                const modelComponentCount = entityGuids.reduce((sum, entityGuid) => {
                    const comps = modelEntities[entityGuid];
                    return sum + (Array.isArray(comps) ? comps.length : 0);
                }, 0);
                
                // Create model node
                const modelItem = createTreeItem(modelName, 'model', modelComponentCount);
                const modelChildren = document.createElement('div');
                modelChildren.className = 'tree-children';

                // Build entity ‚Üí component tree under model
                entityGuids.sort().forEach(entityGuid => {
                    // Find component data for this entity to get better display info
                    const firstCompGuid = modelEntities[entityGuid][0];
                    const firstCompData = firstCompGuid ? data.components?.[firstCompGuid] : null;
                    const entityName = firstCompData?.entityType || `Entity ${entityGuid.substring(0, 8)}`;
                    
                    const entityItem = createTreeItem(entityGuid, 'entity', modelEntities[entityGuid].length, {
                        entityGuid: entityGuid,
                        entityType: entityName
                    });
                    
                    // Update label color based on entity type
                    const entityLabel = entityItem.querySelector('.tree-label');
                    if (entityLabel) entityLabel.classList.add('entity-name');
                    
                    const entityChildren = document.createElement('div');
                    entityChildren.className = 'tree-children';

                    modelEntities[entityGuid].forEach((componentGuid, idx) => {
                        const comp = data.components?.[componentGuid];
                        const componentItem = createTreeItem(componentGuid, 'component', null, comp);
                        const componentChildren = document.createElement('div');
                        componentChildren.className = 'tree-children';

                        // Add component properties (but keep collapsed by default)
                        if (data.components && data.components[componentGuid]) {
                            const comp = data.components[componentGuid];
                            Object.keys(comp).slice(0, 10).forEach(key => {
                                const propItem = createPropertyItem(key, comp[key]);
                                componentChildren.appendChild(propItem);
                            });
                        if (Object.keys(comp).length > 10) {
                            const moreItem = document.createElement('div');
                            moreItem.className = 'tree-item';
                            moreItem.innerHTML = `<div class="tree-item-content" style="color: #888;"><span class="tree-label">... ${Object.keys(comp).length - 10} more properties</span></div>`;
                            componentChildren.appendChild(moreItem);
                        }
                    }

                    componentItem.appendChild(componentChildren);
                    entityChildren.appendChild(componentItem);

                    // Toggle expand on arrow click
                    const componentToggle = componentItem.querySelector('.tree-toggle');
                    if (componentToggle) {
                        componentToggle.addEventListener('click', (e) => {
                            e.stopPropagation();
                            componentItem.classList.toggle('expanded');
                        });
                    }

                    // Toggle expand on text click
                    componentItem.addEventListener('click', (e) => {
                        if (e.target.closest('.tree-toggle, .tree-checkbox')) return;
                        e.stopPropagation();
                        componentItem.classList.toggle('expanded');
                    });

                    // Checkbox for component visibility
                    const checkbox = componentItem.querySelector('.tree-checkbox');
                    checkbox.addEventListener('change', (e) => {
                        selectedGuids[e.target.checked ? 'add' : 'delete'](componentGuid);
                        if (e.target.checked) {
                            renderComponentShapes(componentGuid, data.components?.[componentGuid]);
                        }
                        updateComponentVisibility();
                        updateTableForSelection();
                    });
                });

                entityItem.appendChild(entityChildren);
                modelChildren.appendChild(entityItem);

                // Toggle expand on arrow click
                const entityToggle = entityItem.querySelector('.tree-toggle');
                if (entityToggle) {
                    entityToggle.addEventListener('click', (e) => {
                        e.stopPropagation();
                        entityItem.classList.toggle('expanded');
                    });
                }

                // Toggle expand on text click
                entityItem.addEventListener('click', (e) => {
                    if (e.target.closest('.tree-toggle, .tree-checkbox')) return;
                    e.stopPropagation();
                    entityItem.classList.toggle('expanded');
                });

                // Checkbox for entity
                const checkbox = entityItem.querySelector('.tree-checkbox');
                checkbox.addEventListener('change', (e) => {
                    if (e.target.checked) {
                        modelEntities[entityGuid].forEach(guid => {
                            selectedGuids.add(guid);
                            // Render shapes for all components in this entity
                            renderComponentShapes(guid, data.components?.[guid]);
                        });
                    } else {
                        modelEntities[entityGuid].forEach(guid => selectedGuids.delete(guid));
                    }
                    // Update child checkboxes visually
                    const childCheckboxes = entityItem.querySelectorAll('.tree-children .tree-item .tree-checkbox');
                    childCheckboxes.forEach(cb => cb.checked = e.target.checked);
                    updateComponentVisibility();
                    updateTableForSelection();
                });
                });

                modelItem.appendChild(modelChildren);
                rootChildren.appendChild(modelItem);

                // Toggle expand on arrow click for model
                const modelToggle = modelItem.querySelector('.tree-toggle');
                if (modelToggle) {
                    modelToggle.addEventListener('click', (e) => {
                        e.stopPropagation();
                        modelItem.classList.toggle('expanded');
                    });
                }

                // Toggle expand on text click for model
                modelItem.addEventListener('click', (e) => {
                    if (e.target.closest('.tree-toggle, .tree-checkbox')) return;
                    e.stopPropagation();
                    modelItem.classList.toggle('expanded');
                });

                // Checkbox for model (select/deselect all components in model)
                const modelCheckbox = modelItem.querySelector('.tree-checkbox');
                modelCheckbox.addEventListener('change', (e) => {
                    Object.keys(modelEntities).forEach(entityGuid => {
                        modelEntities[entityGuid].forEach(guid => {
                            if (e.target.checked) {
                                selectedGuids.add(guid);
                                renderComponentShapes(guid, data.components?.[guid]);
                            } else {
                                selectedGuids.delete(guid);
                            }
                        });
                    });
                    // Update child checkboxes visually
                    const childCheckboxes = modelItem.querySelectorAll('.tree-children .tree-checkbox');
                    childCheckboxes.forEach(cb => cb.checked = e.target.checked);
                    updateComponentVisibility();
                    updateTableForSelection();
                });
            }); // CLOSE: models.forEach
            // Toggle expand on arrow click for root
            const rootToggle = rootItem.querySelector('.tree-toggle');
            if (rootToggle) {
                rootToggle.addEventListener('click', (e) => {
                    e.stopPropagation();
                    rootItem.classList.toggle('expanded');
                });
            }

            // Toggle expand on text click for root
            rootItem.addEventListener('click', (e) => {
                if (e.target.closest('.tree-toggle, .tree-checkbox')) return;
                e.stopPropagation();
                rootItem.classList.toggle('expanded');
            });

            // Checkbox for root (select/deselect all)
            const rootCheckbox = rootItem.querySelector('.tree-checkbox');
            rootCheckbox.addEventListener('change', (e) => {
                // Iterate through all models and select/deselect all components
                models.forEach(modelName => {
                    const modelEntities = entitiesByModel[modelName] || {};
                    Object.keys(modelEntities).forEach(entityGuid => {
                        modelEntities[entityGuid].forEach(guid => {
                            if (e.target.checked) {
                                selectedGuids.add(guid);
                                renderComponentShapes(guid, data.components?.[guid]);
                            } else {
                                selectedGuids.delete(guid);
                            }
                        });
                    });
                });
                // Update child checkboxes visually
                const childCheckboxes = rootItem.querySelectorAll('.tree-children .tree-checkbox');
                childCheckboxes.forEach(cb => cb.checked = e.target.checked);
                updateComponentVisibility();
                updateTableForSelection();
            });

            // Append tree to container
            rootItem.appendChild(rootChildren);
            container.appendChild(rootItem);
            
            // Expand root, models, and entities by default - but NOT components
            rootItem.classList.add('expanded');
            // Find all tree items and expand them based on type, but not component items
            const allTreeItems = container.querySelectorAll('.tree-item');
            allTreeItems.forEach(item => {
                const itemType = item.dataset.type;
                // Expand everything except components
                if (itemType !== 'component') {
                    item.classList.add('expanded');
                }
                // Components remain collapsed, which keeps their property children hidden
            });
            
            // Check all checkboxes by default and populate selectedGuids (only if components data available)
            if (data && data.components) {
                const allCheckboxes = container.querySelectorAll('.tree-checkbox');
                allCheckboxes.forEach(checkbox => {
                    checkbox.checked = true;
                    // Add component GUID to selectedGuids if it's a component checkbox
                    const treeItem = checkbox.closest('.tree-item');
                    if (treeItem?.dataset?.guid && treeItem?.dataset?.type === 'component') {
                        selectedGuids.add(treeItem.dataset.guid);
                        // Render the component shape
                        if (data.components[treeItem.dataset.guid]) {
                            try {
                                renderComponentShapes(treeItem.dataset.guid, data.components[treeItem.dataset.guid]);
                            } catch (e) {
                                console.error('Error rendering shape for', treeItem.dataset.guid, e);
                            }
                        }
                    }
                });
                // Update UI after all components are loaded
                try {
                    updateComponentVisibility();
                    updateTableForSelection();
                } catch (e) {
                    console.error('Error updating UI after loading:', e);
                }
            }
        }

        function getIconForType(type, componentData) {
            // Determine icon based on type and component data
            if (type === 'entity') {
                return '‚¨°'; // Hexagon for entity
            } else if (type === 'component') {
                const compType = componentData?.componentType || '';
                const entityType = componentData?.entityType || '';
                if (entityType && compType) return '‚óè'; // Filled circle for component with entityType
                if (compType.includes('ShapeRepresentation')) return '‚ñ≤'; // Triangle for mesh
                if (compType.includes('Relation')) return 'üîó'; // Link for relation
                if (compType.includes('Property')) return '‚äû'; // Squares for properties
                return '‚óÜ'; // Diamond for generic component
            } else if (type === 'model' || type === 'root') {
                return 'üì¶'; // Package
            }
            return '‚Ä¢';
        }

        function getColorClassForComponent(componentData) {
            if (!componentData) return '';
            const compType = componentData.componentType || '';
            const entityType = componentData.entityType || '';
            
            // Check ShapeRepresentation first - it takes priority
            if (compType.includes('ShapeRepresentation')) return 'mesh-name';
            
            // Then check if this is a component with entityType attribute
            if (entityType && compType) {
                return 'component-with-entity-name';
            }
            
            if (compType.includes('Relation')) return 'relation-name';
            if (compType.includes('Property')) return 'property-name';
            if (entityType) return 'entity-name';
            return 'component-name';
        }

        function getIconColorClass(type, componentData) {
            if (type === 'entity') {
                return 'entity';
            } else if (type === 'component') {
                const compType = componentData?.componentType || '';
                const entityType = componentData?.entityType || '';
                if (compType.includes('ShapeRepresentation')) return 'mesh';
                if (entityType && compType) return 'component-with-entity';
                if (compType.includes('Relation')) return 'relation';
                if (compType.includes('Property')) return 'property';
                return 'component';
            }
            return '';
        }

        function createTreeItem(label, type, count, componentData) {
            const item = document.createElement('div');
            item.className = 'tree-item';

            let countText = count !== null ? ` (${count})` : '';
            
            // Determine display name and color
            let displayLabel = label;
            let colorClass = '';
            let icon = getIconForType(type, componentData);
            let guid = label;
            
            if (componentData) {
                // For components, use componentName if available
                if (componentData.componentName) {
                    displayLabel = componentData.componentName;
                } else if (componentData.objectType) {
                    displayLabel = componentData.objectType;
                }
                // Always apply color class based on component data
                colorClass = getColorClassForComponent(componentData);
                guid = componentData.componentGuid || componentData.entityGuid || label;
            } else if (type === 'entity' && componentData === null) {
                // For entity nodes created from the tree structure, we'll need to look up later
                guid = label;
            }
            
            if (displayLabel.length > 40) {
                displayLabel = displayLabel.substring(0, 37) + '...';
            }
            
            // Show short GUID for reference
            const shortGuid = guid.substring(0, 8).toUpperCase();
            const guidDisplay = guid && guid !== label ? `<span class="tree-label-guid">#${shortGuid}</span>` : '';
            
            // Get icon color class
            const iconColorClass = getIconColorClass(type, componentData);
            
            item.innerHTML = `
                <div class="tree-item-content" title="${guid}">
                    <div class="tree-toggle"></div>
                    <input type="checkbox" class="tree-checkbox">
                    <span class="tree-icon ${iconColorClass}" title="${type}">${icon}</span>
                    <span class="tree-label ${colorClass}">${displayLabel}</span>
                    ${guidDisplay}
                    <span class="tree-count">${countText}</span>
                </div>
            `;
            item.dataset.guid = guid;
            item.dataset.type = type;
            return item;
        }

        function createPropertyItem(key, value) {
            const item = document.createElement('div');
            item.className = 'tree-item';

            let valueStr = String(value);
            if (valueStr.length > 50) {
                valueStr = valueStr.substring(0, 47) + '...';
            }

            item.innerHTML = `
                <div class="tree-item-content" style="padding-left: 32px; cursor: default;">
                    <span class="tree-label"><strong>${key}:</strong> ${valueStr}</span>
                </div>
            `;
            return item;
        }

        function updateComponentVisibility() {
            console.log('updateComponentVisibility called, selectedGuids:', Array.from(selectedGuids));
            // Remove meshes that are no longer selected
            const meshesToRemove = [];
            objects3d.forEach((mesh, guid) => {
                // Check if this mesh should be visible
                let shouldBeVisible = false;
                
                if (selectedGuids.has(guid)) {
                    shouldBeVisible = true;
                    console.log(`  ${guid}: directly selected - VISIBLE`);
                } else {
                    // Check if this is a shape mesh (format: componentGuid-item-idx)
                    const componentGuid = guid.includes('-item-') ? guid.split('-item-')[0] : guid;
                    if (selectedGuids.has(componentGuid)) {
                        shouldBeVisible = true;
                        console.log(`  ${guid}: component selected - VISIBLE`);
                    } else {
                        console.log(`  ${guid}: NOT selected - REMOVING`);
                    }
                }
                
                if (!shouldBeVisible) {
                    // Mark mesh for removal
                    meshesToRemove.push(guid);
                    console.log(`  Removing mesh from scene: ${guid}`);
                    scene.remove(mesh);
                } else {
                    // Make visible
                    mesh.visible = true;
                }
            });
            
            // Remove meshes from tracking
            meshesToRemove.forEach(guid => {
                objects3d.delete(guid);
                console.log(`  Deleted from objects3d: ${guid}`);
            });
            
            console.log(`Total meshes remaining: ${objects3d.size}, selectedGuids size: ${selectedGuids.size}`);
            
            // Force an immediate render after visibility changes
            renderer.render(scene, camera);
        }

        function updateTableForSelection() {
            if (selectedGuids.size === 0 || !currentData) {
                updateTable([]);
                return;
            }

            const rows = [];
            selectedGuids.forEach(guid => {
                if (currentData && currentData.components && currentData.components[guid]) {
                    const comp = currentData.components[guid];
                    Object.keys(comp).forEach(key => {
                        rows.push({ guid, key, value: comp[key] });
                    });
                }
            });

            updateTable(rows);
        }

        function updateTable(rows) {
            const container = document.getElementById('tableContainer');
            const rowCount = document.getElementById('rowCount');

            if (rows.length === 0) {
                container.innerHTML = '<div class="empty-state">Select components to view data</div>';
                rowCount.textContent = '';
                return;
            }

            let html = `
                <table>
                    <thead>
                        <tr>
                            <th>GUID</th>
                            <th>Property</th>
                            <th>Value</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            rows.forEach(row => {
                const guidShort = row.componentGuid.substring(0, 8) + '...';
                const valueStr = String(row.value).length > 100 
                    ? String(row.value).substring(0, 97) + '...'
                    : row.value;
                html += `
                    <tr title="${row.value}">
                        <td>${guidShort}</td>
                        <td>${row.key}</td>
                        <td>${valueStr}</td>
                    </tr>
                `;
            });

            html += `</tbody></table>`;
            container.innerHTML = html;
            rowCount.textContent = `(${rows.length} rows)`;
        }

        // ============================================
        // API INTERACTION
        // ============================================
        async function executeQuery() {
            const input = document.getElementById('queryInput').value.trim();
            if (!input) return;

            const status = document.getElementById('statusText');
            status.innerHTML = 'Loading<span class="loading"></span>';

            try {
                // CLEAR ALL PRIOR DATA AND MESHES
                // Remove all 3D objects from scene
                objects3d.forEach(mesh => scene.remove(mesh));
                objects3d.clear();
                selectedGuids.clear();
                
                // Clear UI
                document.getElementById('treeContainer').innerHTML = '';
                updateInformationView(null);
                updateTable([]);
                currentData = null;

                // Parse the query - support full URLs with server/port
                let url = input;
                
                // If it's a full URL (has protocol), use it as-is
                if (url.startsWith('http://') || url.startsWith('https://')) {
                    // Already a full URL, use as-is
                } 
                // If it starts with /, add default server
                else if (url.startsWith('/')) {
                    url = 'http://localhost:5000' + url;
                }
                // If it starts with 'api/', add / prefix and server
                else if (url.startsWith('api/')) {
                    url = 'http://localhost:5000/' + url;
                }
                // Otherwise assume it's a path, add / and server
                else {
                    url = 'http://localhost:5000/api/' + url;
                }

                console.log('Executing query:', url);

                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const apiData = await response.json();
                if (apiData.error) {
                    throw new Error(apiData.error);
                }

                // Display raw API response in Info tab
                updateInformationView(apiData);

                // Build data structure for tree
                const data = {
                    entities: {},
                    components: {}
                };

                // Detect response type and handle accordingly
                let allEntityGuids = [];
                const urlObj = new URL(url);
                const endpoint = urlObj.pathname;

                // Handle entityGuids endpoint (model-organized dictionary)
                if (endpoint.includes('/entityGuids')) {
                    // Format: {modelName: [guid1, guid2, ...]}
                    // This endpoint returns just entity GUIDs, no component data
                    console.log('Processing entityGuids response:', Object.keys(apiData));
                    
                    // ORGANIZE DATA BY MODEL: entities structure will be {modelName: {entityGuid: []}}
                    data.entities = {};
                    data.models = Object.keys(apiData).filter(key => Array.isArray(apiData[key]));
                    console.log('Set data.models to:', data.models);
                    
                    // Populate entity guids from all models
                    for (const [modelName, guids] of Object.entries(apiData)) {
                        if (Array.isArray(guids)) {
                            console.log(`Found ${guids.length} entity guids in model ${modelName}`);
                            // Initialize model entry in entities with each entity guid as a key
                            data.entities[modelName] = {};
                            guids.forEach(entityGuid => {
                                data.entities[modelName][entityGuid] = []; // Empty array - no component data from this endpoint
                            });
                            console.log(`Initialized data.entities[${modelName}] with ${guids.length} entity keys`);
                        }
                    }
                    console.log('‚úì Entity GUIDs loaded - no component data expected from /api/entityGuids endpoint');
                }
                // Handle componentGuids endpoint (model-organized dictionary)
                else if (endpoint.includes('/componentGuids')) {
                    // Format: {modelName: [guid1, guid2, ...]}
                    console.log('Processing model-organized componentGuids response:', Object.keys(apiData));
                    
                    // ORGANIZE DATA BY MODEL
                    data.entities = {};
                    data.models = Object.keys(apiData).filter(key => Array.isArray(apiData[key]));
                    console.log('Set data.models to:', data.models);
                    
                    // Collect all component guids from all models
                    let allComponentGuids = [];
                    for (const [modelName, guids] of Object.entries(apiData)) {
                        if (Array.isArray(guids)) {
                            allComponentGuids.push(...guids);
                            console.log(`Found ${guids.length} component guids in model ${modelName}`);
                            // Initialize model entry in entities
                            data.entities[modelName] = {};
                        }
                    }
                    
                    const baseUrl = `${urlObj.protocol}//${urlObj.host}`;
                    
                    if (allComponentGuids.length > 0) {
                        const compUrl = baseUrl + '/api/components?componentGuids=' + 
                            allComponentGuids.slice(0, 100).join(',');
                        try {
                            const compResponse = await fetch(compUrl);
                            const compData = await compResponse.json();
                            
                            if (Array.isArray(compData)) {
                                compData.forEach(comp => {
                                    const entityGuid = comp.entityGuid || 'Unknown';
                                    const modelName = comp.model || 'DefaultModel';
                                    
                                    // Organize by model, then by entity
                                    if (!data.entities[modelName]) {
                                        data.entities[modelName] = {};
                                    }
                                    if (!data.entities[modelName][entityGuid]) {
                                        data.entities[modelName][entityGuid] = [];
                                    }
                                    if (!data.entities[modelName][entityGuid].includes(comp.componentGuid)) {
                                        data.entities[modelName][entityGuid].push(comp.componentGuid);
                                    }
                                    data.components[comp.componentGuid] = comp;
                                });
                            }
                        } catch (e) {
                            console.error('Error fetching component data:', e);
                        }
                    }
                }
                // Handle components endpoint (model-organized dictionary with component details)
                else if (endpoint.includes('/components') && typeof apiData === 'object' && !Array.isArray(apiData)) {
                    // Format: {modelName: [component1, component2, ...]}
                    console.log('Processing components response (model-organized):', Object.keys(apiData));
                    
                    // ORGANIZE DATA BY MODEL: entities structure will be {modelName: {entityGuid: [compGuids]}}
                    data.entities = {};
                    data.models = Object.keys(apiData).filter(key => Array.isArray(apiData[key]));
                    console.log('Set data.models to:', data.models);
                    
                    // Process each model's components
                    for (const [modelName, components] of Object.entries(apiData)) {
                        if (Array.isArray(components)) {
                            console.log(`Found ${components.length} components in model ${modelName}`);
                            // Initialize model entry in entities
                            data.entities[modelName] = {};
                            
                            // Organize components by entity GUID
                            components.forEach(comp => {
                                const entityGuid = comp.entityGuid || 'Unknown';
                                const componentGuid = comp.componentGuid;
                                
                                // Create entity entry if needed
                                if (!data.entities[modelName][entityGuid]) {
                                    data.entities[modelName][entityGuid] = [];
                                }
                                
                                // Add component GUID to entity's component list
                                if (!data.entities[modelName][entityGuid].includes(componentGuid)) {
                                    data.entities[modelName][entityGuid].push(componentGuid);
                                }
                                
                                // Store full component data
                                data.components[componentGuid] = comp;
                            });
                            
                            console.log(`Organized ${components.length} components into ${Object.keys(data.entities[modelName]).length} entities`);
                        }
                    }
                    console.log('‚úì Components loaded and organized by model and entity');
                }
                else if (Array.isArray(apiData)) {
                    // Direct array response (models, entity_types, or components)
                    console.log('Processing array response:', apiData.length);
                    
                    if (endpoint.includes('/components') && apiData.length > 0 && apiData[0].componentGuid) {
                        // Component data array - organize by model and entity GUID (deprecated format)
                        // Collect models from the component data
                        const modelsInData = [...new Set(apiData.map(comp => comp.model || 'DefaultModel'))];
                        data.models = modelsInData;
                        
                        // Organize by model, then by entity
                        apiData.forEach(comp => {
                            const entityGuid = comp.entityGuid || 'Unknown';
                            const modelName = comp.model || 'DefaultModel';
                            
                            if (!data.entities[modelName]) {
                                data.entities[modelName] = {};
                            }
                            if (!data.entities[modelName][entityGuid]) {
                                data.entities[modelName][entityGuid] = [];
                            }
                            if (!data.entities[modelName][entityGuid].includes(comp.componentGuid)) {
                                data.entities[modelName][entityGuid].push(comp.componentGuid);
                            }
                            data.components[comp.componentGuid] = comp;
                        });
                    } else if (endpoint.includes('/models')) {
                        // Models list
                        data.entities['Models'] = apiData;
                        data.models = ['Models'];
                    } else if (endpoint.includes('/entity_types')) {
                        // Entity types list
                        data.entities['Entity Types'] = apiData;
                        data.models = ['Entity Types'];
                    } else {
                        // Unknown array
                        data.entities['Result'] = apiData;
                        data.models = ['Result'];
                    }
                }
                else {
                    console.warn('Unknown response type, data structure will be empty');
                    data.modelName = 'Unknown';
                }

                // Only update tree, not info (info is already updated with raw response)
                console.log('=== BEFORE buildTree ===');
                console.log('data.models:', data.models);
                console.log('data.entities keys:', Object.keys(data.entities));
                console.log('data.entities:', JSON.stringify(data.entities, null, 2).substring(0, 3000));
                console.log('data.components count:', Object.keys(data.components).length);
                console.log('======================');
                
                buildTree(data);
                updateTable([]);
                currentData = data;
                console.log('FINAL DATA STRUCTURE:', {
                    models: data.models,
                    entityKeys: Object.keys(data.entities),
                    entityCount: Object.keys(data.entities).length,
                    componentCount: Object.keys(data.components).length
                });
                status.textContent = `‚úì Loaded ${Object.keys(data.components).length} components (${Object.keys(data.entities).length} entities/models)`;

            } catch (error) {
                console.error('Query failed:', error);
                const errorMsg = error.message || 'Unknown error';
                status.textContent = `‚úó Error: ${errorMsg}`;
                document.getElementById('treeContainer').innerHTML = 
                    `<div class="empty-state">Error: ${errorMsg}<br><small style="color: #aaa;">Check browser console (F12) for details</small></div>`;
            }

            console.log('=== FINAL SUMMARY ===');
            console.log('Query URL:', input);
            console.log('Final data entities:', Object.keys(currentData?.entities || {}).length);
            console.log('Final data components:', Object.keys(currentData?.components || {}).length);
        }

        function clearResults() {
            document.getElementById('queryInput').value = '';
            document.getElementById('statusText').textContent = 'Ready';
            document.getElementById('treeContainer').innerHTML = 
                '<div class="empty-state">Execute a query to load data</div>';
            updateTable([]);
            selectedGuids.clear();
            objects3d.forEach(mesh => scene.remove(mesh));
            objects3d.clear();
        }

        // ============================================
        // EVENT HANDLERS
        // ============================================
        document.getElementById('executeBtn').addEventListener('click', executeQuery);
        document.getElementById('clearBtn').addEventListener('click', clearResults);

        document.getElementById('queryInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                executeQuery();
            }
        });

        // Initialize on load
        window.addEventListener('load', () => {
            console.log('üìç Page loaded');
            console.log('   THREE available:', typeof THREE !== 'undefined');
            console.log('‚úì Viewer initialized with custom OBJ parser');
            init3DViewer();
            setupTabSwitching();
        });
    </script>
</body>
</html>
